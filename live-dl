#!/bin/bash
#
# Live Downloader
# Download live streams from YouTube
#
# Tunghsiao Liu <t@sparanoid.com>
# Released under AGPL-3.0
#

#
# System reqirements
#
# - aria2c
# - bash
# - exiv2
# - ffmpeg
# - jq
# - youtube-dl
# - yq (python-yq)
# - pytchat

#
# To-do list
#
# - [x] dependencies check
# - [x] youtube playlist support (not perfect when writing metadata)
# - [x] thumbnail size check
# - [x] write metadata and cover
# - [x] email notification
# - [x] mailgun setup guide
# - [x] slack notification
# - [x] telegram notification
# - [X] discord notification
# - [x] refine telegram multichannel support
# - [x] channel name mapping
# - [x] download base dir support
# - [x] upcoming streams detection
# - [x] keyword filter
# - [x] metadata overriding mode
# - [x] summary output for uploading
# - [x] recording summary
# - [x] embed cover
# - [x] add hostname to output
# - [x] dockerize this script
# - [x] rewrite is_live detection logic
#

#
# Variables
#
USER_AGENT="Mozilla/5.0 (Macintosh; Intel Mac OS X 11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36"
IMAGE_PROXY_BASE="https://experiments.sparanoid.net/imageproxy/"

#
# Functions
#

# Text color helper borrowed from acme.sh
__green() {
  printf '\033[1;31;32m%b\033[0m' "$1"
}

__yellow() {
  printf '\033[1;31;33m%b\033[0m' "$1"
}

__red() {
  printf '\033[1;31;40m%b\033[0m' "$1"
}

__info() {
  printf "[$(date)] %s\n" "$1"
}

__debug() {
  DEBUG="${PARAM_DEBUG:-"false"}"
  if [ "$DEBUG" == "true" ]; then
    printf "[$(date)] DEBUG: %s\n" "$1"
  fi
}

# Convert secs to HH:MM:SS format
__convert_seconds() {
  # https://stackoverflow.com/a/39452629/412385
  printf '%02d:%02d:%02d\n' $(($1/3600)) $(($1%3600/60)) $(($1%60))
}

# Set the current working directory to the directory of this script
# http://stackoverflow.com/a/17744637/412385
cd ${0%/*}

# Prepare options
POSITIONAL=()
while [ $# -gt 0 ]; do
  key="$1"

  case $key in
    -e|--extension)
      EXTENSION="$2"
      shift # past argument
      shift # past value
      ;;
    -m|--mode)
      PARAM_MODE="$2"
      shift
      shift
      ;;
    -o|--output)
      PARAM_BASE_DIR="$2"
      shift
      shift
      ;;
    -mb|--membership)
      PARAM_MEMBERSHIP=true
      shift
      ;;
    -nl|--no-log)
      PARAM_NO_LOG=true
      shift
      ;;
    -yt|--ytarchive)
      PARAM_YTARCHIVE=true
      shift
      ;;
    -ao|--audio-only)
      PARAM_AUDIO_ONLY=true
      shift
      ;;
    -rt|--remove-title)
      PARAM_REMOVE_TITLE=true
      shift
      ;;
    -ac|--archive-chat)
      PARAM_ARCHIVE_CHAT=true
      PARAM_ARCHIVE_CHAT_MODE=simple
      shift
      ;;
    -acf|--archive-chat-full)
      PARAM_ARCHIVE_CHAT=true
      PARAM_ARCHIVE_CHAT_MODE=full
      shift
      ;;
    -kf|--keyword-filter)
      PARAM_KEYWORD_FILTER=true
      shift
      ;;
    --filter)
      PARAM_FILTER="$2"
      shift
      shift
      ;;
    -i|--interval)
      PARAM_INTERVAL="$2"
      shift
      shift
      ;;
    -li|--long-interval)
      PARAM_LONG_INTERVAL="$2"
      shift
      shift
      ;;
    --init)
      PARAM_INIT_SCRIPT=true
      shift
      ;;
    --debug)
      PARAM_DEBUG=true
      shift
      ;;
    --skip-metadata)
      PARAM_SKIP_METADATA=true
      shift
      ;;
    --skip-email)
      PARAM_SKIP_EMAIL=true
      shift
      ;;
    --skip-slack)
      PARAM_SKIP_SLACK=true
      shift
      ;;
    --skip-telegram)
      PARAM_SKIP_TELEGRAM=true
      shift
      ;;
    --skip-discord)
      PARAM_SKIP_DISCORD=true
      shift
      ;;
    --callback)
      PARAM_CALLBACK=true
      PARAM_CALLBACK_EXEC="$2"
      shift
      shift
      ;;
    --address-pool)
      PARAM_ADDRESS_POOL=true
      PARAM_ADDRESS_POOL_FILE="$2"
      shift
      shift
      ;;
    -1|--once)
      PARAM_ONE_TIME=true
      shift
      ;;
    --image-proxy)
      PARAM_IMAGE_PROXY=true
      shift
      ;;
    *) # other unknown options
      POSITIONAL+=("$1") # save it in an array for later
      shift
      ;;
  esac
done

# restore positional parameters
set -- "${POSITIONAL[@]}"

function func_create_url() {
  # Create correct URL/URI based on user input
  #
  # https://www.youtube.com/channel/UCxRuOqAAVo-f516Gygjh_wA/live
  # https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg
  # https://www.youtube.com/watch?v=S3CAGeeMRvo
  # https://www.youtube.com/playlist?list=UU1opHUrw8rvnsadT-iGp7Cg
  # https://www.youtube.com/feed/subscriptions
  # https://live.bilibili.com/14917277
  # https://live.bilibili.com/456117
  #

  local _url=$1

  if [[ "$_url" =~ "youtube.com" ]] || [[ "$_url" =~ "youtu.be" ]]; then
    __info "YouTube URL detected"
    DL_PLATFORM="YouTube"

    if [[ "$_url" =~ "/channel" && "$_url" =~ "/live" ]]; then
      __info "YouTube channel detected"
      DL_URL="$_url"
      DL_TYPE="channel"

    elif [[ "$_url" =~ "/channel" && ! "$_url" =~ "/live" && ! "$_url" =~ "/community" && ! "$_url" =~ "/membership" ]]; then
      __info "YouTube video detected (alt)"
      DL_URL="$_url/live"
      DL_TYPE="channel"

    elif [[ "$_url" =~ "/channel" && "$_url" =~ "/community" ]] || [[ "$_url" =~ "/channel" && "$_url" =~ "/membership" ]]; then
      __info "YouTube membership detected (member only stream)"
      DL_URL="$_url"
      DL_TYPE="channel"
      DL_OPTION="membership"

    elif [[ "$_url" =~ "/watch"* ]]; then
      __info "YouTube video detected"
      DL_URL="$_url"
      DL_TYPE="video"

    elif [[ "$_url" =~ "/playlist"* ]]; then
      __info "YouTube playlist detected"
      DL_URL="$_url"
      DL_TYPE="playlist"

    elif [[ "$_url" =~ "youtu.be"* ]]; then
      __info "Short YouTube video detected"
      _url=`echo "$_url"|sed 's/https:\/\/youtu.be\///'`
      DL_URL="https://www.youtube.com/watch?v=$_url"
      DL_TYPE="video"

    else
      __info "$(__red "Non-supported YouTube URL")"
      exit 1
    fi
  elif [[ "$_url" =~ "twitch.tv" ]]; then
    __info "Twitch detected"
    DL_URL="$_url"
    DL_PLATFORM="Twitch"
    DL_TYPE="Twitch"

  elif [[ "$_url" =~ "live.bilibili.com" ]]; then
    __info "Bilibili detected"
    DL_URL="$_url"
    DL_PLATFORM="bilibili"

  else
    if [[ ! "$_url" == "http"* ]]; then
      __info "$(__yellow "URI detected, guessing... (Use full URL to avoid guessing URL)")"

      if [[ "$_url" =~ ^([0-9]+)$ ]]; then
        __info "Bilibili room ID detected"
        DL_URL="https://live.bilibili.com/$_url"
        DL_PLATFORM="bilibili"

      # if URI is longer than 11 (11 is the length of YouTube video ID)
      elif [[ ${#_url} -ge 12 ]]; then
        __info "YouTube channel ID detected"
        DL_URL="https://www.youtube.com/channel/$_url/live"
        DL_PLATFORM="YouTube"
        DL_TYPE="channel"

      else
        __info "YouTube video ID detected"
        DL_URL="https://www.youtube.com/watch?v=$_url"
        DL_PLATFORM="YouTube"
        DL_TYPE="video"
      fi

    else
      __info "$(__red "Non-supported URL")"
      exit 1
    fi
  fi
}

function func_gen_curl_address_param() {
  if [[ "$ADDRESS_POOL" == "true" && "$ADDRESS_POOL_FILE" != "/dev/null" ]]; then
    local ip=$(shuf -n 1 "${ADDRESS_POOL_FILE}")
    echo "--interface ${ip}"
  else
    echo ""
  fi
}

function func_gen_youtube_dl_address_param() {
  if [[ "$ADDRESS_POOL" == "true" && "$ADDRESS_POOL_FILE" != "/dev/null" ]]; then
    local ip=$(shuf -n 1 "${ADDRESS_POOL_FILE}")
    echo "--source-address ${ip}"
  else
    echo ""
  fi
}

function func_get_actual_video_url_of_live() {
  local _url=$1
  local regex="https:\/\/www.youtube.com\/channel\/(.+)\/live"
  if [[ "$_url" =~ $regex ]] ; then
    local CHANNEL_ID="${BASH_REMATCH[1]}"

    # Get video url
    local _url="https://www.youtube.com/embed/live_stream?channel=${CHANNEL_ID}"
    local regex='.+?<link rel="canonical" href="(.+)">.+'

    local address_param=$(func_gen_curl_address_param)
    local _body=$(curl $address_param -s -H "User-Agent: $USER_AGENT" "$_url")

    [[ "$_body" =~ $regex ]]
    local VIDEO_URL="${BASH_REMATCH[1]%%\"*}"
    echo "$VIDEO_URL"
  else
    echo "$_url"
  fi
}

function func_check_update() {
  # Check the last modified live-dl with the latest live-dl on github
  # I don't want install Git on docker, so use api is enough
  local LASTCOMMIT=`curl -s --compressed -H "Accept: application/vnd.github.v3+json" -s "https://api.github.com/repos/herowinb/live-dl/commits?page=1&per_page=1" | jq -r '.[0].commit.committer.date'`
  local LASTCOMMIT=`date -d $LASTCOMMIT "+%s"`
  local LASTMODIFY=`date -r ./live-dl "+%s"`
  # add 3600s
  local LASTMODIFY=`expr $LASTMODIFY + 3600`

  if [[ "$LASTCOMMIT" > $LASTMODIFY ]] ; then
    UPDATENOTE="

            **************************************************************************
                            You are using an outdated live-dl version
                       Pleease check https://github.com/herowinb/live-dl
                Update new docker image https://hub.docker.com/r/herowinb/live-dl
            **************************************************************************
            "
    UPDATENOTE_SHORT="**You are using an outdated live-dl version**"
      __info "$UPDATENOTE"
    else
      UPDATENOTE=""
      UPDATENOTE_SHORT=""
      __debug "$(__yellow "Live-dl is up to date")"
    fi
}

function func_select_cookies() {
if [[ "$DL_OPTION" == "membership" ]] || [[ "$PARAM_MEMBERSHIP" == "true" ]] ; then
  # Select cookies_membership.txt for members only post
  COOKIES_FILE="./config/cookies_membership.txt"
else
  COOKIES_FILE="./config/cookies.txt"
fi
}

function func_select_log() {
if [[ "$NO_LOG" == "true" ]] ; then
  # Select cookies_membership.txt for members only post
  LOG_PATH="/dev/null"
else
  LOG_PATH="$OUTPUT_PATH.log"
fi
}

function func_check_membership() {
  local _body=$(curl -s --compressed -H "User-Agent: $USER_AGENT" $address_param -b "$COOKIES_FILE" "$_url")
  # Check cookies_membership is valid by checking if the Membership tab exists or not.
  # All posts in Mebership tab are member-only.
  local TAB_URL=`echo "$_body" |sed -n 's/.*var ytInitialData = \({[^<]*}\);.*/\1/p'| jq -r '.contents.twoColumnBrowseResultsRenderer.tabs[4].tabRenderer.endpoint.commandMetadata.webCommandMetadata.url | select(.!=null)'`
  __debug "Tab Membership check: $TAB_URL"

  if [[ $TAB_URL =~ "/membership" ]] ; then

    # Take first VideoID from all posts have Badges "Members only"
    local _CURL_RAW=`echo "$_body" | sed -n 's/.*var ytInitialData = \({[^<]*}\);.*/\1/p'| jq -r '.contents.twoColumnBrowseResultsRenderer.tabs[3].tabRenderer.content.sectionListRenderer.contents[0].itemSectionRenderer.contents[] | select(.backstagePostThreadRenderer.post.backstagePostRenderer.backstageAttachment.videoRenderer.badges[0].metadataBadgeRenderer.label=="Members only")'`
    local _CURL_RAW_VIDEO_ID=`echo $_CURL_RAW | grep -Eo 'videoId": "[^"]+'| head -1`
    local _VIDEO_ID=`echo ${_CURL_RAW_VIDEO_ID##*'"'}`
    if [ -n "$_VIDEO_ID" ]; then
      _url="https://www.youtube.com/watch?v=$_VIDEO_ID"
      __debug "Detected member only stream $_url"
      # Reset counter
      retry_membership=0
    else
      __debug "LiveDL can detect member-only posts but can not found any VideoID."
      # Reset counter
      retry_membership=0
    fi
  else
    # Retry and loop
    retry_membership=$((retry_membership+1))
    __info "Retrying to detect member only stream. $retry_membership time(s) "
    sleep 20
  fi
}

function func_check_state() {
  local _url=$1
  local _mode=$2


  __debug "start func_check_state"

  # Assume it's not a valid page, I use a custom state `invalid` here as initial state
  CONTENT_STATE="invalid"

  # Actually there's an official way to check if the streamer is live or not[^1] using YouTube
  # offical Data API, but it's costy that every search request costs you 100 credits. However
  # you can try it online[^2] to see how it works.
  #
  # If you have accounts that registered YouTube developer program before 2017, and has more
  # than 10 million credit quota, you can contact me t@sparanoid.com
  #
  # [1]: https://developers.google.com/youtube/v3/docs/search
  # [2]: https://developers.google.com/youtube/v3/code_samples/code_snippets

  # First check: use curl to check HTML pages for live state
  # Pros:
  # - Fast, no additional API requests compared to youtube-dl
  # - More ban-proof compared to youtube-dl
  # Cons:
  # - Can get wrong live state due to page caching, network interrupts, etc.
  local address_param=$(func_gen_curl_address_param)
  if [ "$address_param" ]; then
    __info "using address: ${address_param##* }"
  fi

  # Select cookies for member only stream
  func_select_cookies
  __debug "Cookies using: $COOKIES_FILE"

  # Replace membership URL by community URL
  local regex_membership="https:\/\/www.youtube.com\/channel\/(.+)\/membership"
  if [[ "$_url" =~ $regex_membership ]] ; then
    _url=${_url/membership/community}
  fi

  # If url is Youtube community page,it need redirect channel page check to
  # video page after got the specific video ID.
  local regex_community="https:\/\/www.youtube.com\/channel\/(.+)\/community"
  if [[ "$_url" =~ $regex_community ]] ; then
    # Add a counter
    local retry_membership=0
    func_check_membership

    # Retrying 5 times
    if [ $retry_membership -ge 1 ]; then
      while [ $retry_membership -le 4 ]; do
        func_check_membership
        # Break loop if got member-only posts
        if [[ $retry_membership == "0" ]]; then
          break
        fi
      done
    fi

    # After retry 5 times, send notification
    if [ $retry_membership == "5" ]; then
      func_send_discord "cookies"
      __info "Can not detect member only stream, make sure your cookies_membership.txt is not expired and from an account joined membership of channel $_url"
    fi
  fi

  if [[ "$_url" =~ $regex_community ]] ; then
    METADATA_CURL_RAW=""
    PLAYABILITY="invalid"
    __debug "Skip curl check because no VideoID found in member-only posts or cookies_membership expired."

  else

    # Passing useragent causes youtube to return the content to one line. Then grep died.
    local _body=$(curl -s --compressed -H "User-Agent: $USER_AGENT" $address_param -b "$COOKIES_FILE" -s "$_url")

  fi
  # Extract metadata from fetched page
  # METADATA_CURL_RAW=`echo "$_body" | grep -a 'ytInitialPlayerResponse' | grep -a '<script' | grep -a 'responseContext'`

  # Match only JSON part
  # https://regex101.com/r/QiyZE2/3
  #
  # Debug commmand if YouTube changes its HTML structure in the future:
  # $ curl -s --compressed -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36" 'https://www.youtube.com/watch?v=j2z06YUbulk' | grep 'ytInitialPlayerResponse' | grep '<script' | grep 'responseContext' | perl -pe 's/^.*?ytInitialPlayerResponse = ({".*]});var .*/\1/g' | jq -r .
  METADATA_CURL=`echo "$_body" | sed -n 's/.*var ytInitialPlayerResponse = \({[^<]*}\);.*/\1/p'| jq -r .`
  # Check if returns nothing
  if [ ! -z "$METADATA_CURL" ]; then
    __debug "Got valid cURL metadata"

    # At the time of writing, when `videoDetails.isLive` exists, it should be on live, when a video
    # is not live (normal videos, and even upcoming streams) this key will be missing and jq will
    # return `null`
    IS_LIVE=$(echo "$METADATA_CURL" | jq -r '.videoDetails.isLive | select(.!=null)')
    __debug "Is live: $IS_LIVE"

    # This status will always return:
    # - `OK` for live streams, private streams, or normal videos,
    # - `LIVE_STREAM_OFFLINE` for offline channel
    PLAYABILITY=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.status | select(.!=null)')
    __debug "Playability: $PLAYABILITY"

    # You will get some playability reasons for:
    # - `Offline` for streams are not live
    # - `This live event will begin in {n} hours.` for upcoming streams, you can also get specific
    #   UNIX timestamp with .scheduledStartTime (see below)
    # - `null` (this key will be missing) for:
    #   - On live streams or private streams
    #   - Non-streaming content
    PLAYABILITY_REASON=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.reason | select(.!=null)')
    __debug "Playability Reason: $PLAYABILITY_REASON"

    # When the streamer is streaming privately, this key will be empty
    STREAMABILITY=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.liveStreamability.liveStreamabilityRenderer.videoId | select(.!=null)')
    __debug "Streamability ID: $STREAMABILITY"

    # Get upcoming time when available
    # This key will be missing if no upcoming events available
    UPCOMING_TIME=$(echo "$METADATA_CURL" | jq -r '.playabilityStatus.liveStreamability.liveStreamabilityRenderer.offlineSlate.liveStreamOfflineSlateRenderer.scheduledStartTime | select(.!=null)')
    __debug "Scheduled Start Time: $UPCOMING_TIME"

    # Get some metadata first, I will retrieve more later using youtube-dl
    VIDEO_ID=$(echo "$METADATA_CURL" | jq -r '.videoDetails.videoId')
    FULLTITLE=$(echo "$METADATA_CURL" | jq -r '.videoDetails.title')
    DESCRIPTION=$(echo "$METADATA_CURL" | jq -r '.videoDetails.shortDescription')
    UPLOADER=$(echo "$METADATA_CURL" | jq -r '.videoDetails.author')
    CHANNEL_ID=$(echo "$METADATA_CURL" | jq -r '.videoDetails.channelId')

    # NOTE: Oct 25, 2020
    # With recent changes of YouTube API, you cannot get live JSON from a /live channel URL.
    # This causes empty response during youtube-dl second check. So I redirect channel page check to
    # video page check after I got the specific video ID.
    if ([ "$DL_TYPE" == "channel" ] && [ "$DL_PLATFORM" == "YouTube" ]); then
      _url="https://www.youtube.com/watch?v=$VIDEO_ID"
    fi
    # If I got `isLive: true` in first check, let me assume it's live but I can't trust it so I
    # will do a secound check using youtube-dl later with this flag.
    if [ "$IS_LIVE" == "true" ]; then
      __info "cURL check seems goes live now, continue checking..."

      if [ "$KEYWORD_FILTER" == "true" ]; then
        #read keyword in keyword.txt
        local _FILTER=$(cat ./config/keyword.txt)
        _FILTER="${_FILTER//\\}"

        __debug "User filter found: "$FILTER""
        __debug "User filter found (Keyword.txt): "$_FILTER""

        #compares FULLTITLE with keyword
        if [ ! -z "$FILTER" ] && [[ "$FULLTITLE" =~ $FILTER ]]; then
          __debug "Video title matched, mark as downloadable..."
          CONTENT_STATE="live"
        elif [[ "$FULLTITLE" =~ $_FILTER ]]; then
          __debug "Video title matched, mark as downloadable..."
          CONTENT_STATE="live"
        else
          CONTENT_STATE="invalid"
          __info "Video title is not match with keyword, skipping and continue monitoring..."
        fi
      else
      __debug "No keyword filter run, mark as downloadable..."
      CONTENT_STATE="live"
      fi

    else
      # If `isLive` key not exists, check if it's a valid video (playable)
      if [ "$PLAYABILITY" == "OK" ]; then
        # Then check if it's a channel URL
        if [ "$DL_TYPE" == "channel" ]; then
          if [ "$DL_OPTION" == "membership" ]; then
            # Skip download member only stream if it is not live
            PLAYABILITY="invalid"
            __debug "Detected member only stream but it not live, skip download"
          else
          # Check if the streamer is streaming privately.
            __info "$(__yellow "/live redirects to /, event mode or streaming privately?")"
          fi
        else
          CONTENT_STATE="video"
        fi
      fi

      # Then check if the stream just goes offline
      if [ "$PLAYABILITY" == "LIVE_STREAM_OFFLINE" ]; then
        CONTENT_STATE="offline"

        # Check if upcoming event available
        if [ ! -z "$UPCOMING_TIME" ]; then
          local _date_calc=`date -d @$UPCOMING_TIME`
          __info "$(__yellow "Upcoming event detected: $_date_calc")"
        fi
      fi
    fi

    # Print current state for first check
    __debug "Current state for first check: $(__yellow "$CONTENT_STATE")"
  else
    __debug "$(__yellow "Not a valid page, something wrong with your internet connection?")"
  fi

  # Second check: use `youtube-dl` to check live state
  # NOTE: please avoid adding additional paths in the -o (template) option, it doesn't work well
  # and conflicts with my custom directory setup!
  # I also need redirect stderr to stdout to catch any error during fetching URL
  # Pros:
  # - Accurate live state detection
  # Cons:
  # - Slow, youtube-dl will fire API requests to get more info it need to download videos
  # - Your IP can get banned easily when running in download or notifier mode due to large amount of
  #   API requests.
  if [ "$CONTENT_STATE" != "invalid" ]; then

    # Condition explain:
    # Only run second check when:
    # - The stream goes live that need a second check to ensure it's actually live
    # - The stream goes offline that need a second check to ensure it's actually offline
    if ([ "$CONTENT_STATE" != "offline" ] && [ "$_mode" != "lazy" ]) || \
      ([ "$CONTENT_STATE" == "offline" ] && [ "$_mode" == "lazy" ])
    then
      __info "Re-checking via youtube-dl..."

      local _url=$(func_get_actual_video_url_of_live "$_url")
      __info "Get real video url: $_url"
      local _youtube_dl_address_param=$(func_gen_youtube_dl_address_param)
      if [ "$_youtube_dl_address_param" ]; then
        __info "using address: ${_youtube_dl_address_param##* }"
      fi
      METADATA=`youtube-dl --ignore-config --no-playlist --playlist-items 0 --cookies "$COOKIES_FILE" \
        --skip-download --print-json --referer 'https://www.youtube.com/feed/subscriptions' \
        -o '%(upload_date)s %(title)s (%(id)s).%(ext)s' \
        ${_youtube_dl_address_param} \
        "$_url" 2>&1`

      # Check if returns nothing
      if [ ! -z "$METADATA" ]; then
        __debug "Got valid youtube-dl metadata"

        # Check if it's a valid JSON return
        if [[ "$METADATA" == '{'* ]]; then
          # Unlike other part of the jq checks, I ignore the `| select(.!=null)` to explicitly
          # return `null` to tell if it's a normal video or it just returns nothing
          local _is_live=`echo "$METADATA" | jq -r '.is_live'`

          # Parse metadata
          func_process_youtube_metadata

          # Map uploader name with pre-defined config
          func_process_channel_mapping

          # Finalize variables and paths then output summary
          func_finalize_vars

          if [ "$_is_live" == "true" ]; then
            __debug "Got state: live";
            CONTENT_STATE="live"
          elif [ "$_is_live" == "null" ]; then
            __debug "Got state: video";
            CONTENT_STATE="video"
          else
            __info "youtube-dl does not returns a valid state";
            CONTENT_STATE="invalid"
          fi
        else
          __debug "$METADATA"
          if [[ "$METADATA" =~ "This video is unavailable" ]]; then
            # Suppress `video is unavailable` errors since they're common when stream is not live
            __debug "This video is unavailable, maybe not live at the moment."
            CONTENT_STATE="unavailable"
          elif [[ "$METADATA" =~ "HTTP Error 404" ]]; then
            __info "$(__yellow "Not a valid video page (Error 404)!")"
            CONTENT_STATE="not_found"
          elif [[ "$METADATA" =~ "HTTP Error 429" ]]; then
            __info "$(__yellow "Your IP is limited by YouTube (Error 429)! Check here: https://github.com/herowinb/live-dl/issues/3 ")"
            CONTENT_STATE="too_many_requests"
          else
            __info "$(__yellow "Unknown metadata")"
            __info "$METADATA"
            CONTENT_STATE="invalid"
          fi
        fi
      else
        __info "$(__yellow "Second check failed, not valid youtube-dl metadata")"
        CONTENT_STATE="invalid"
      fi

      # Print current state for second check
      __debug "Current state for second check: $(__yellow "$CONTENT_STATE")"
    fi
  fi
}

# Clone of func_check_state but for Twitch
function func_check_state_twitch() {
  local _url=$1
  local _mode=$2

  __debug "start func_check_state_twitch"

  CONTENT_STATE="invalid"

  local address_param=$(func_gen_curl_address_param)
  if [ "$address_param" ]; then
    __info "using address: ${address_param##* }"
  fi

  local _body=$(curl -s --compressed -H "User-Agent: $USER_AGENT" $address_param -b "$COOKIES_FILE" -s "$_url")

  if [[ "$_body" == *"isLiveBroadcast"* ]]; then

    METADATA_CURL=`echo "$_body" | sed 's/^.*application\/ld+json">//' | sed 's/<\/script.*$//' | jq -r . `

    if [ ! -z "$METADATA_CURL" ]; then
      __debug "Got valid cURL metadata"

      IS_LIVE=$(echo $METADATA_CURL | jq -r '.[].publication.isLiveBroadcast | select(.!=null)')
      __debug "Is live: $IS_LIVE"
      UPLOADER=$(echo "$METADATA_CURL" | jq -r '.[].name')
    fi

    if [ "$IS_LIVE" == "true" ]; then
      CONTENT_STATE="live"
      __info "cURL check seems goes live now, continue checking..."
    fi

    if ([ "$CONTENT_STATE" == "live" ] && [ "$_mode" != "lazy" ]); then
      __info "Re-checking via youtube-dl..."

      local _youtube_dl_address_param=$(func_gen_youtube_dl_address_param)
      if [ "$_youtube_dl_address_param" ]; then
        __info "using address: ${_youtube_dl_address_param##* }"
      fi
      METADATA=`youtube-dl --ignore-config --no-playlist --playlist-items 0 --cookies "$COOKIES_FILE" \
        --skip-download --print-json --referer 'https://www.twitch.tv/directory' \
        -o '%(upload_date)s %(title)s (%(id)s).%(ext)s' \
        ${_youtube_dl_address_param} \
        "$_url" 2>&1`

      if [ ! -z "$METADATA" ]; then
        __debug "Got valid youtube-dl metadata"

        if [[ "$METADATA" == '{'* ]]; then
          # use 2>/dev/null to ignore errors line when use jq
          local _is_live=`echo "$METADATA" | jq '.is_live' 2>/dev/null`

          VIDEO_ID=$(echo "$METADATA" | jq -r '.id' 2>/dev/null)
          FULLTITLE=$(echo "$METADATA" | jq -r '.description' 2>/dev/null) # Default .fulltitle is Twitchusername (live) date time. So don't use it
          DESCRIPTION=$(echo "$METADATA" | jq -r '.description' 2>/dev/null)
          UPLOAD_DATE=$(echo "$METADATA" | jq -r '.upload_date' 2>/dev/null)
          UPLOADER=$(echo "$METADATA" | jq -r '.uploader' 2>/dev/null)
          CHANNEL_ID=$(echo "$METADATA" | jq -r '.webpage_url' 2>/dev/null)
          THUMBNAIL=$(echo "$METADATA" | jq -r '.thumbnail' 2>/dev/null)
          WEBPAGE_URL=$(echo "$METADATA" | jq -r '.webpage_url' 2>/dev/null)
          CHANNEL_URL=$(echo "$METADATA" | jq -r '.webpage_url' 2>/dev/null)

          if [ $REMOVE_TITLE == "true" ]; then
              __info "Running remove title function..."
              FILENAME=$(echo "$UPLOAD_DATE ($VIDEO_ID)")
          else
              FULLTITLE=`escape_filename "${FULLTITLE}"`
              FILENAME=$(echo "$UPLOAD_DATE $FULLTITLE ($VIDEO_ID)")
          fi

          func_process_channel_mapping

          func_finalize_vars

          if [ "$_is_live" == "true" ]; then
            __debug "Got state: live";
            CONTENT_STATE="live"
          else
            __info "youtube-dl does not returns a valid state";
            CONTENT_STATE="invalid"
          fi
        else
          __debug "$METADATA"
          if [[ "$METADATA" =~ "This video is unavailable" ]]; then
            # Suppress `video is unavailable` errors since they're common when stream is not live
            __debug "This video is unavailable, maybe not live at the moment."
            CONTENT_STATE="unavailable"
          elif [[ "$METADATA" =~ "HTTP Error 404" ]]; then
            __info "$(__yellow "Not a valid video page (Error 404)!")"
            CONTENT_STATE="not_found"
          elif [[ "$METADATA" =~ "HTTP Error 429" ]]; then
            __info "$(__yellow "Your IP is limited by YouTube (Error 429)! Check here: https://github.com/herowinb/live-dl/issues/3 ")"
            CONTENT_STATE="too_many_requests"
          elif [[ "$METADATA" =~ "is offline" ]]; then
            __debug "Stream already offline or maybe not live at the moment."
            CONTENT_STATE="offline"
          else
            __info "$(__yellow "Unknown metadata")"
            __info "$METADATA"
            CONTENT_STATE="invalid"
          fi
        fi
      else
        __info "$(__yellow "Second check failed, not valid youtube-dl metadata")"
        CONTENT_STATE="invalid"
      fi

      # Print current state for second check
      __debug "Current state for second check: $(__yellow "$CONTENT_STATE")"
    fi
  fi
}

function func_send_email() {
  local _title=$1
  local _content=$2

  if [ "$SKIP_EMAIL" != "true" ]; then

    if [ "$CONFIG_EMAIL_PROVIDER" == "mailgun" ]; then

      if [ "$CONFIG_MAILGUN_API" == "key-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" ]; then
        __info "$(__yellow "No Mailgun credentials found, skip sending email notification")"
      else
        __info "Sending email notification..."
        curl -s --user "api:$CONFIG_MAILGUN_API" \
          https://api.mailgun.net/v3/"$CONFIG_MAILGUN_DOMAIN"/messages \
          -F from="Livestream Downloader (live-dl) <live-dl@$CONFIG_MAILGUN_DOMAIN>" \
          -F to="$CONFIG_MAILGUN_RECEIPT" \
          -F subject="$_title" \
          -F text="$_content" >> "$LOG_PATH" 2>&1
      fi
    fi

    if [ "$CONFIG_EMAIL_PROVIDER" == "ses" ]; then

      if [ "$CONFIG_SES_ACCESS" == "AKxxxxxxxxxxxxxxxxxx" ]; then
        __info "$(__yellow "No AWS SES credentials found, skip sending email notification")"
      else
        __info "Sending email notification..."
        local FROM="Livestream Downloader (live-dl) <live-dl@$CONFIG_SES_DOMAIN>"

        local ses_date="$(date -R)"
        # base64 different behavior alert:
        # https://stackoverflow.com/a/46464081/412385
        # Just use `base64` or `base64 -b 0` on macOS, on other platforms, use:
        # `base64 -w 0`
        local ses_signature="$(echo -n "$ses_date" | openssl dgst -sha256 -hmac "$CONFIG_SES_SECRET" -binary | base64)"
        local ses_auth_header="X-Amzn-Authorization: AWS3-HTTPS AWSAccessKeyId=$CONFIG_SES_ACCESS, Algorithm=HmacSHA256, Signature=$ses_signature"
        local ses_endpoint="https://email.us-east-1.amazonaws.com/"
        local ses_action="Action=SendEmail"
        local ses_source="Source=$FROM"
        local ses_to="Destination.ToAddresses.member.1=$TO"
        local ses_subject="Message.Subject.Data=$_title"
        local ses_message="Message.Body.Text.Data=$_content"

        curl -X POST -H "Date: $ses_date" -H "$ses_auth_header" \
          --data-urlencode "$ses_message" \
          --data-urlencode "$ses_to" \
          --data-urlencode "$ses_source" \
          --data-urlencode "$ses_action" \
          --data-urlencode "$ses_subject" \
          "$ses_endpoint" >/dev/null 2>&1
      fi
    fi
  fi
}

function func_send_slack() {
  local _type=$1

  if [ "$SKIP_SLACK" != "true" ]; then

    if [ "$CONFIG_SLACK_WEBHOOK" == "https://hooks.slack.com/services/" ]; then
      __info "$(__yellow "No Slack credentials found, skip sending Slack notification")"
    else
      __info "Sending Slack notification..."

      if [ "$_type" == "start" ]; then
        local _body='{
          "icon_emoji": ":red_circle:",
          "channel": "'"$UPLOADER"'",
          "text": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "attachments": [
            {
              "fallback": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"'",
              "color": "#f570de",
              "fields": [
                {
                  "title": "Title",
                  "value": "'"$FULLTITLE"'",
                  "short": false
                },
                {
                  "title": "ID",
                  "value": "<'"$WEBPAGE_URL"'|'"$VIDEO_ID"'>",
                  "short": true
                },
                {
                  "title": "Channel",
                  "value": "<'"$CHANNEL_URL"'|'"$CHANNEL_ID"'>",
                  "short": true
                },
                {
                  "title": "Thumbnail",
                  "value": "<'"$THUMBNAIL_CALC"'|View in new tab>",
                  "short": true
                },
                {
                  "title": "Date",
                  "value": "'"$UPLOAD_DATE"'",
                  "short": true
                }
              ]
            }
          ]
        }'
      elif [ "$_type" == "stop" ]; then
        local _body='{
          "icon_emoji": ":black_square:",
          "channel": "'"$UPLOADER"'",
          "text": "'"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "attachments": [
            {
              "fallback": "'"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"'",
              "color": "#f570de",
              "fields": [
                {
                  "title": "Title",
                  "value": "'"$FULLTITLE"'",
                  "short": false
                },
                {
                  "title": "Views",
                  "value": "'"$VIEW_COUNT"'",
                  "short": true
                },
                {
                  "title": "Likes",
                  "value": "'"$LIKE_COUNT"'",
                  "short": true
                },
                {
                  "title": "Dislikes",
                  "value": "'"$DISLIKE_COUNT"'",
                  "short": true
                },
                {
                  "title": "Average Rating",
                  "value": "'"$AVERAGE_RATING"'",
                  "short": true
                }
              ]
            }
          ]
        }'
      else
        local _body='{
          "icon_emoji": ":ghost:",
          "channel": "'"$UPLOADER"'",
          "text": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"' '"$WEBPAGE_URL"'",
          "attachments": [
            {
              "fallback": "'"$UPLOADER"' goes live on '"$DL_PLATFORM"'",
              "color": "#f570de",
              "fields": [
                {
                  "title": "Title",
                  "value": "'"$FULLTITLE"'",
                  "short": false
                },
                {
                  "title": "ID",
                  "value": "<'"$WEBPAGE_URL"'|'"$VIDEO_ID"'>",
                  "short": true
                },
                {
                  "title": "Channel",
                  "value": "<'"$CHANNEL_URL"'|'"$CHANNEL_ID"'>",
                  "short": true
                },
                {
                  "title": "Thumbnail",
                  "value": "<'"$THUMBNAIL_CALC"'|View in new tab>",
                  "short": true
                },
                {
                  "title": "Date",
                  "value": "'"$UPLOAD_DATE"'",
                  "short": true
                }
              ]
            }
          ]
        }'
      fi

      curl -s -X POST -H 'Content-type: application/json' -o /dev/null \
        -d "$_body" "$CONFIG_SLACK_WEBHOOK"
    fi
  fi
}

function func_send_telegram() {
  local _type=$1

  # https://core.telegram.org/bots/api
  if [ "$SKIP_TELEGRAM" != "true" ]; then

    if [ "$CONFIG_TELEGRAM_BOT" == "000000000:xxxxxxxxx" ]; then
      __info "$(__yellow "No Telegram credentials found, skip sending Telegram notification")"
    else
      if [ "$UPLOADER_TG_CHANNEL" ]; then
        __info "Sending Telegram notification..."
        local _time_start=$(TZ=":$UPLOADER_TIMEZONE" date +"%b %e %H:%M %Z (%z)")

        if [ "$_type" == "start" ]; then
          local _type="sendPhoto"
          local _body='{
            "chat_id": "'"$UPLOADER_TG_CHANNEL"'",
            "photo": "'"$THUMBNAIL_CALC"'",
            "caption": "üî¥ '"$UPLOADER"' goes live on '"$DL_PLATFORM"'\n'"$FULLTITLE"'\n\nStarts on '"$_time_start"'",
            "reply_markup": {
              "inline_keyboard": [
                [
                  {"text": "Watch it now", "url": "'"$WEBPAGE_URL"'"}
                ],
                [
                  {"text": "View channel", "url": "'"$CHANNEL_URL"'"},
                  {"text": "View artwork", "url": "'"$IMAGE_PROXY_BASE$THUMBNAIL_CALC"'"}
                ]
              ]
            },
            "disable_notification": false
          }'
        elif [ "$_type" == "stop" ]; then
          local _type="sendMessage"
          local _body='{
            "chat_id": "'"$UPLOADER_TG_CHANNEL"'",
            "text": "‚¨õÔ∏è '"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"'\n'"$FULLTITLE"'\n\nViews: '"$VIEW_COUNT"'\nLikes: '"$LIKE_COUNT"'\nDislikes: '"$DISLIKE_COUNT"'\nAverage Rating: '"$AVERAGE_RATING"'",
            "reply_markup": {
              "inline_keyboard": [
                [
                  {"text": "Watch finished stream", "url": "'"$WEBPAGE_URL"'"}
                ]
              ]
            },
            "disable_notification": true
          }'
        else
          local _type="sendMessage"
          local _body='{
            "chat_id": "'"$UPLOADER_TG_CHANNEL"'",
            "text": "üî¥ '"$UPLOADER"' goes live on '"$DL_PLATFORM"'\n'"$FULLTITLE"'\n'"$WEBPAGE_URL"'",
            "reply_markup": {
              "inline_keyboard": [
                [
                  {"text": "Watch it now", "url": "'"$WEBPAGE_URL"'"}
                ],
                [
                  {"text": "View channel", "url": "'"$CHANNEL_URL"'"},
                  {"text": "View artwork", "url": "'"$IMAGE_PROXY_BASE$THUMBNAIL_CALC"'"}
                ]
              ]
            },
            "disable_notification": false
          }'
        fi

        curl -s -X POST -H 'Content-Type: application/json' -o /dev/null \
          -d "$_body" "https://api.telegram.org/bot$CONFIG_TELEGRAM_BOT/$_type"
      else
        __info "No specific channel set for current user, skip sending Telegram notification."
      fi
    fi
  fi
}

function func_send_discord() {
  local _type=$1

  if [ "$SKIP_DISCORD" != "true" ]; then

    if [ "$CONFIG_DISCORD_BOT" == "0000000000000.aaaaaa.bbbbbbbbbbbbbbbbbb" ]; then
      __info "$(__yellow "No Discord credentials found, skip sending Discord notification")"
    else
      if [ "$CONFIG_DISCORD_CHANNEL" != "0000000000000" ]; then

      if [ "$_type" == "start" ]; then
        local _body='{
          "content": ":red_circle: '"$UPLOADER"' goes live on '"$DL_PLATFORM"' '"$UPDATENOTE_SHORT"' '"$MODE_AUDIO_TEXT"'",
          "embed": {
            "author": {
              "name": "'"$UPLOADER"'",
              "url": "'"$CHANNEL_URL"'"
            },
            "title": "'"$FULLTITLE"'",
            "url": "'"$WEBPAGE_URL"'",
            "color": 15258703,
            "fields": [
              {
                "name": "Channel",
                "value": "['"$UPLOADER"']('"$CHANNEL_URL"')",
                "inline": true
              },
              {
                "name": "Thumbnail",
                "value": "[View in new tab]('"$THUMBNAIL_CALC"')",
                "inline": true
              }
            ],
            "image": {
              "url": "'"$THUMBNAIL_CALC"'"
            }
          }
        }'
      elif [ "$_type" == "stop" ]; then
        local _body='{
          "content": ":white_square_button: '"$UPLOADER"' stopped streaming on '"$DL_PLATFORM"'",
          "embed": {
            "author": {
              "name": "'"$UPLOADER"'",
              "url": "'"$CHANNEL_URL"'"
            },
            "title": "'"$FULLTITLE"'",
            "url": "'"$WEBPAGE_URL"'",
            "color": 16085214,
            "fields": [
              {
                "name": "Duration",
                "value": "'"$FILE_SUMMARY_DURATION_CALC"'",
                "inline": true
              },
              {
                "name": "Size",
                "value": "'"$FILE_SUMMARY_SIZE_CALC"'",
                "inline": true
              }
            ]
          }
        }'
      elif [ "$_type" == "cookies" ]; then
        local _body='{
          "content": " :warning: Can not detect member only stream, make sure your cookies_membership.txt is not expired and from an account joined membership of channel '"$_url"'"
        }'
      fi
      __info "Sending Discord notification..."
      curl -s -X POST -H 'Content-type: application/json' -o /dev/null \
           --header "Authorization: Bot $CONFIG_DISCORD_BOT" \
           -d "$_body" "https://discord.com/api/channels/$CONFIG_DISCORD_CHANNEL/messages"
      else
        __info "No Discord channel set, skip sending Discord notification."
      fi
    fi
  fi
}

# Detect profile file if not specified as environment variable
# Borrowed from acme.sh
function func_detect_profile() {
  if [ -n "$PROFILE" -a -f "$PROFILE" ]; then
    echo "$PROFILE"
    return
  fi

  DETECTED_PROFILE=''
  SHELLTYPE="$(basename "/$SHELL")"

  if [ "$SHELLTYPE" = "bash" ]; then
    if [ -f "$HOME/.bashrc" ]; then
      DETECTED_PROFILE="$HOME/.bashrc"
    elif [ -f "$HOME/.bash_profile" ]; then
      DETECTED_PROFILE="$HOME/.bash_profile"
    fi
  elif [ "$SHELLTYPE" = "zsh" ]; then
    DETECTED_PROFILE="$HOME/.zshrc"
  fi

  if [ -z "$DETECTED_PROFILE" ]; then
    if [ -f "$HOME/.profile" ]; then
      DETECTED_PROFILE="$HOME/.profile"
    elif [ -f "$HOME/.bashrc" ]; then
      DETECTED_PROFILE="$HOME/.bashrc"
    elif [ -f "$HOME/.bash_profile" ]; then
      DETECTED_PROFILE="$HOME/.bash_profile"
    elif [ -f "$HOME/.zshrc" ]; then
      DETECTED_PROFILE="$HOME/.zshrc"
    fi
  fi

  echo "$DETECTED_PROFILE"
}

function remove_datetime_in_title {
  local org="$1"
  # fulltitle from youtube-dl: „Äê‚ôØ10„Äë„Ç™„É´„Ç≠„Çπ„Å°„ÇÉ„Çì„ÇíÊïë„ÅÑ„Åü„ÅÑÔºöGRANBLUE FANTASY„Äê„Éõ„É≠„É©„Ç§„Éñ/Â§ßÁ©∫„Çπ„Éê„É´„Äë 2021-03-02 10:36
  local regex="(.+) [[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2} [[:digit:]]{2}[\:_][[:digit:]]{2}"
  if [[ "$org" =~ $regex ]]; then
    echo "${BASH_REMATCH[1]}${BASH_REMATCH[3]}"
  else
    echo "$org"
  fi
}

function escape_filename {
  # Remove Invalid characters in filename
  # https://support.microsoft.com/en-us/office/invalid-file-names-and-file-types-in-onedrive-and-sharepoint-64883a5d-228e-48f5-b3d2-eb39e07630fa?ui=en-US&rs=en-US&ad=US#invalidcharacters
  # Replace " * : < > ? / \ | by _
  local filename="$1"
  filename="${filename//\"/_}"
  filename="${filename//\*/_}"
  filename="${filename//\:/_}"
  filename="${filename//\</_}"
  filename="${filename//\>/_}"
  filename="${filename//\?/_}"
  filename="${filename//\//_}"
  filename="${filename//\\/_}"
  filename="${filename//\|/_}"
  echo "${filename}"
}

function func_process_youtube_metadata() {
  # Extract video info from JSON
  VIDEO_ID=$(echo "$METADATA" | jq -r '.id')
  # 2021.3.1
  # youtube-dl and its fork Changed its live stream title format (embed datetime into the title)
  # So we now deprecate getting title from youtube-dl unless we got nothing from curl
  if [[ -z "$FULLTITLE" ]]; then
    FULLTITLE=$(echo "$METADATA" | jq -r '.fulltitle')
    # Remove datetime in title from METADATA youtube-dl
    FULLTITLE=`remove_datetime_in_title "${FULLTITLE}"`
  fi
  DESCRIPTION=$(echo "$METADATA" | jq -r '.description')
  UPLOAD_DATE=$(echo "$METADATA" | jq -r '.upload_date')
  UPLOADER=$(echo "$METADATA" | jq -r '.uploader')
  CHANNEL_ID=$(echo "$METADATA" | jq -r '.channel_id')
  THUMBNAIL=$(echo "$METADATA" | jq -r '.thumbnail')
  WEBPAGE_URL=$(echo "$METADATA" | jq -r '.webpage_url')
  CHANNEL_URL=$(echo "$METADATA" | jq -r '.channel_url')
  VIEW_COUNT=$(echo "$METADATA" | jq -r '.view_count')
  LIKE_COUNT=$(echo "$METADATA" | jq -r '.like_count')
  DISLIKE_COUNT=$(echo "$METADATA" | jq -r '.dislike_count')
  AVERAGE_RATING=$(echo "$METADATA" | jq -r '.average_rating')

  # Filename (without path)
  # Remove TITLE function
  if [ $REMOVE_TITLE == "true" ]; then
      __info "Running remove title function..."
      FILENAME=$(echo "$UPLOAD_DATE ($VIDEO_ID)")
  else
      # Youtube-dl _filename added datetime
      # FILENAME=$(echo "$METADATA" | jq -r '._filename' | sed -e 's/.mp4//' | sed -e 's/.webm//')
      # Remove invalid filename
      FULLTITLE=`escape_filename "${FULLTITLE}"`
      FILENAME=$(echo "$UPLOAD_DATE $FULLTITLE ($VIDEO_ID)")
  fi
}

function func_process_channel_mapping() {
  # Find channel name mapping
  # https://stackoverflow.com/a/40027637/412385

  if [ "$CHANNEL_ID" ]; then
    if [[ $DL_PLATFORM == "Twitch" ]]; then
      UPLOADER_MAPPED_RAW=`echo "$CONFIG_RAW" | jq -r --arg CHANNEL_ID "$CHANNEL_ID" \
        '.map[] | select(.twitch==$CHANNEL_ID)'`
    else
      UPLOADER_MAPPED_RAW=`echo "$CONFIG_RAW" | jq -r --arg CHANNEL_ID "$CHANNEL_ID" \
        '.map[] | select(.youtube | contains($CHANNEL_ID))'`
    fi

    # Check if current uploader has custom name mapping in config
    UPLOADER_MAPPED=`echo "$UPLOADER_MAPPED_RAW" | jq -r .name`

    if [ ! -z "${UPLOADER_MAPPED// }" ]; then
      __debug "Channel name mapping found: $(__yellow "$UPLOADER") ‚Üí $(__green "$UPLOADER_MAPPED")"
      __debug "I will use $(__green "$UPLOADER_MAPPED") for folder name, embedding metadata, etc."
      UPLOADER="$UPLOADER_MAPPED"
    else
      __debug "Channel name mapping $(__yellow "not found"), consider adding it in config.yml"
      __debug "I will use $(__yellow "$UPLOADER") for folder name, embedding metadata, etc."
    fi

    # Check if current uploader has dedicated Telegram channel
    UPLOADER_TG_CHANNEL=`echo "$UPLOADER_MAPPED_RAW" | jq -r '.telegram | select (.!=null)'`

    if [ "${UPLOADER_TG_CHANNEL}" ]; then
      __debug "Telegram channel found: $(__green "$UPLOADER_TG_CHANNEL")"
    else
      __debug "Telegram channel $(__yellow "not found"), consider adding it in config.yml"
    fi

    # Check if current uploader has custom timezone
    UPLOADER_TIMEZONE=`echo "$UPLOADER_MAPPED_RAW" | jq -r '.timezone | select (.!=null)'`

    if [ -z "$UPLOADER_TIMEZONE" ]; then
      UPLOADER_TIMEZONE=`echo "$CONFIG_RAW" | jq -r '.config.timezone'`
    fi

  else
    __info "$(__red "Missing uploader ID!")"
    exit 1
  fi
}

function func_prepare_dir() {
  local _dir=$1
  [ -d "$_dir" ] || mkdir -p "$_dir"
}

function func_create_file_name() {
  # Output $file_base_name.X if $file_base_name$EXTENSION exists.
  # prevents the 6hr overwrite issue.

  local file_base_name="${1:-$FILENAME}"
  local output_dir="${2:-$OUTPUT_BASE}"

  if [ -f "$output_dir/${file_base_name}.mp4" ] || \
     [ -f "$output_dir/${file_base_name}.m4a" ] || \
     [ -f "$output_dir/${file_base_name}.log" ] || \
     [ -f "$output_dir/${file_base_name}.jpg" ] || \
     [ -f "$output_dir/${file_base_name}.finished" ]
  then
    local -i NUM_POSTFIX=1
    while [ -f "$output_dir/${file_base_name}.${NUM_POSTFIX}${EXTENSION}" ]; do
      let NUM_POSTFIX+=1
    done
    echo "${file_base_name}.${NUM_POSTFIX}"
  else
    echo $file_base_name
  fi
}

function func_finalize_vars() {
  # Output preffix dir (without user base dir)
  # Also I replace slash with underscores here to avoid nesting directories
  # i.e.
  # Â§©ÂÆÆ „Åì„Åì„Çç / Kokoro Amamiya „Äê„Å´„Åò„Åï„Çì„ÅòÊâÄÂ±û„Äë will become:
  # Â§©ÂÆÆ „Åì„Åì„ÇçÔºèKokoro Amamiya „Äê„Å´„Åò„Åï„Çì„ÅòÊâÄÂ±û„Äë
  EXTENSION=".mp4"
  FILENAME_BASE=$(echo "$UPLOADER" | sed "s/\//Ôºè/" | sed "s/ Ôºè /Ôºè/")

  # Output base without filename
  OUTPUT_BASE="$BASE_DIR/$FILENAME_BASE"
  # Output base for membership
  if [[ $DL_OPTION == "membership" ]] || [[ $PARAM_MEMBERSHIP == "true" ]]; then
    if [[ $CONFIG_DIR_MEMBERSHIP == "true" ]]; then
      OUTPUT_BASE="$BASE_DIR/$FILENAME_BASE/membership"
    fi
  fi

#  if [[ $DL_PLATFORM == "Twitch" ]]; then
#    OUTPUT_BASE="$BASE_DIR/$FILENAME_BASE/twitch"
#  fi

  # Full output dir
  FILENAME=$(func_create_file_name "$FILENAME" "$OUTPUT_BASE")
  OUTPUT_PATH="$OUTPUT_BASE/$FILENAME"

  # Write prettified JSON metadata to file
  func_prepare_dir "$OUTPUT_BASE"
  METADATA_PRETTIFIED=`echo $METADATA | jq . 2>/dev/null`
  echo "$METADATA_PRETTIFIED" > "$OUTPUT_PATH.json"

  # Select logs location
  func_select_log

  THUMBNAIL_CALC="$THUMBNAIL"
  curl -s "$THUMBNAIL_CALC" -o "$OUTPUT_PATH.jpg"

  # Output summary
  SUMMARY="ID:        $VIDEO_ID
Title:     $FULLTITLE
URL:       $WEBPAGE_URL
Author:    $UPLOADER
Channel:   $CHANNEL_URL
Date:      $UPLOAD_DATE
Thumbnail: $THUMBNAIL_CALC
Filename:  $FILENAME
Location:  $OUTPUT_BASE/
Hostname:  $HOSTNAME
"

  # Trim additional whitespace, used by email body
  SUMMARY_TRIM=`echo "$SUMMARY" | perl -pe 's/: +/: /g'`
}

function func_archive_chat() {
  local _type=$1

  if [ $ARCHIVE_CHAT == "true" ]; then
    __info "Calling chat-downloader to run archive chat."

    if [ $ARCHIVE_CHAT_MODE == "simple" ]; then
      __debug "Running simple mode."
      chat_downloader \
        --cookies "$COOKIES_FILE" \
        --format example \
        --format_file ./config/chat-format.json \
        --output "${OUTPUT_PATH}-chat.txt" \
        "${WEBPAGE_URL}" >/dev/null 2>&1

    elif [ $ARCHIVE_CHAT_MODE == "full" ]; then
      __debug "Running full mode."
      chat_downloader \
        --cookies "$COOKIES_FILE" \
        --output "${OUTPUT_PATH}-chat.json" \
        "${WEBPAGE_URL}" >/dev/null 2>&1

    fi

  else
    __debug "No run archive chat."
  fi
}

function func_download_youtube() {
  __info "Start downloading $FILENAME"

  # Log tail inspired by https://github.com/printempw/live-stream-recorder
  __info "Logging: tail -f \"$LOG_PATH\""

  if [ "$CONTENT_STATE" == "live" ]; then

    if [ "$YTARCHIVE" == "true" ]; then

      if [ "$PARAM_AUDIO_ONLY" == "true" ]; then
        FORTMAT_OPTION="audio_only"
      else
        FORTMAT_OPTION="best"
      fi

      python /usr/src/app/ytarchive.py \
        --no-wait \
        -o "${OUTPUT_PATH}" \
        -c "$COOKIES_FILE" \
        --save \
        --merge \
        --no-frag-files \
        -r 30 \
        "${WEBPAGE_URL}" $FORTMAT_OPTION >> "$LOG_PATH" 2>&1

    else

      if [ "$PARAM_AUDIO_ONLY" == "true" ]; then
        FORTMAT_OPTION="-f 91 -x"
      fi

  	youtube-dl \
  		--ignore-config \
      --hls-prefer-native \
  		--hls-use-mpegts \
      --no-part \
  		--fragment-retries 30 \
      --retries 60 \
      $FORTMAT_OPTION \
  		--cookies "$COOKIES_FILE" \
  		-o "${OUTPUT_PATH}${EXTENSION}" \
  		"${WEBPAGE_URL}" >> "$LOG_PATH" 2>&1
    fi

  elif [ "$CONTENT_STATE" == "video" ]; then

    if [ "$PARAM_AUDIO_ONLY" == "true" ]; then
      FORTMAT_OPTION="bestaudio[ext=m4a]"
    else
      FORTMAT_OPTION="bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best"
    fi

    if [ "$DL_TYPE" == "playlist" ]; then
      # TODO: You have to loop over all the videos to add metadata and thumbnail manually.
      # Or you can add the following parameters to handle it using youtube-dl automatically:
      #   --embed-thumbnail # requires AtomicParsley
      #   --add-metadata
      youtube-dl \
        --ignore-config \
        --download-archive archive.txt \
        --embed-thumbnail \
        --add-metadata \
        --external-downloader aria2c \
        --external-downloader-args '-j 16 -s 16 -x 16 -k 1M --retry-wait 10 --max-tries 10' \
        -f "$FORTMAT_OPTION" \
        --retries 30 \
		    --cookies "$COOKIES_FILE" \
		    --merge-output-format mp4 \
        -o "$OUTPUT_PATH.%(ext)s" \
        "${WEBPAGE_URL}" >> "$LOG_PATH" 2>&1
    else
      youtube-dl \
        --ignore-config \
        --external-downloader aria2c \
        --external-downloader-args '-j 16 -s 16 -x 16 -k 1M --retry-wait 10 --max-tries 10' \
        -f "$FORTMAT_OPTION" \
        --retries 30 \
		    --cookies "$COOKIES_FILE" \
		    --merge-output-format mp4 \
        -o "$OUTPUT_PATH.%(ext)s" \
        "${WEBPAGE_URL}" >> "$LOG_PATH" 2>&1
    fi
  else
    __info "Not a valid URL, skippping"
  fi
}

function func_download_twitch() {
  __info "Start downloading $FILENAME"

  # Log tail inspired by https://github.com/printempw/live-stream-recorder
  __info "Logging: tail -f \"$LOG_PATH\""

  if [ "$CONTENT_STATE" == "live" ]; then
  	youtube-dl \
  		--ignore-config \
      --hls-prefer-native \
  		--hls-use-mpegts \
      --no-part \
  		--fragment-retries 30 \
      --retries 60 \
      $FORTMAT_OPTION \
  		--cookies "$COOKIES_FILE" \
  		-o "${OUTPUT_PATH}${EXTENSION}" \
  		"${WEBPAGE_URL}" >> "$LOG_PATH" 2>&1
    fi
}

function func_download_bilibili() {
  __info "bilibili download func"
}

function func_finalize_download() {
  __info "Stop downloading"

  # Download thumbnail
  # youtube-dl has built-in thumbnail download feature via --write-all-thumbnails but it's not
  # perfect due to the limitation of YouTube API, youtube-dl will only get `hqdefault.jpg` for
  # finished streams (live streams not affected) because offical API only returns this size even
  # higher resolution is available (`maxresdefault.jpg`). So I created some additional checks here.
  #
  # For stream content, YouTube provides both `maxresdefault.jpg` and `maxresdefault_live.jpg`, but
  # `maxresdefault.jpg` is more reliable as `maxresdefault_live.jpg` will return black image
  # (200 HTTP code) even if the streamer set a smaller thumbnail that is only suitable at a smaller
  # size (hqdefault.jpg)
  #
  # Another scenario is that the streamer set an upcoming event with thumbnail-A. But she/he later
  # changes it to another (thumbnail-B) when stream goes live. `maxresdefault_live.jpg` seems always
  # returns thumbnail-A while `maxresdefault.jpg` can get the correct thumbnail-B.
  #
  # First download thumbnail provided from youtube-dl
  curl -s "$THUMBNAIL_CALC" -C - -o "$OUTPUT_PATH.jpg"

  # Check thumbnail width
  THUMB_W=`exiv2 "$OUTPUT_PATH.jpg" | awk -F: '/Image size/ {print $2}' | cut -dx -f1 | tr -d ' '`
  if [ "$THUMB_W" -lt "1280" ]; then
    __info "Thumbnail ($THUMBNAIL_CALC) downloeded via youtube-dl is too small, try our own method"

    # Re-assign thumbnail URL
    THUMBNAIL_CALC="https://i.ytimg.com/vi/$VIDEO_ID/maxresdefault.jpg"

    # Check if thumbnail is available (has 200 HTTP response code)
    local _thumb_resp=$(curl -qSsfw "%{http_code}" $THUMBNAIL_CALC -o /dev/null)

    if [ "$_thumb_resp" != "200" ]; then
      __info "No high-res thumbnial (maxresdefault.jpg), failback to hqdefault.jpg"
      THUMBNAIL_CALC="https://i.ytimg.com/vi/$VIDEO_ID/hqdefault.jpg"
      curl -s "$THUMBNAIL_CALC" -o "$OUTPUT_PATH.jpg"
    else
      curl -s "$THUMBNAIL_CALC" -o "$OUTPUT_PATH.jpg"
    fi
  fi

  if [ $SKIP_METADATA == "false" ]; then
    __info "Trying to write metadata and artwork"

    # Write metadata to MP4 (will override existing with -y option)
    if [ -f "$OUTPUT_PATH.mp4" ]; then
      __info "Writing metadata"
      ffmpeg -i "$OUTPUT_PATH.mp4" -y \
        -codec copy \
        -metadata title="$FULLTITLE" \
        -metadata artist="$UPLOADER" \
        -metadata date="$UPLOAD_DATE" \
        -metadata description="$DESCRIPTION" \
        -metadata comment="$DESCRIPTION" \
        -movflags faststart \
        "$OUTPUT_PATH-metadata.mp4" >> "$LOG_PATH" 2>&1
      rm -f "$OUTPUT_PATH.mp4" && mv "$OUTPUT_PATH-metadata.mp4" "$OUTPUT_PATH.mp4"
    else
      __info "$(__yellow "Output file not exists, skip writing metadata.")"
    fi

    # Writing artwork cover
    # I have to emabed artwork and metadata in two separate steps be cause FFmpeg can't pipe these
    # two steps into one. And AtomicParsley also doesn't support medatada in-file writing.
    if [ -f "$OUTPUT_PATH.mp4" ]; then
      __info "Writing artwork"

      # Check if artwork avaiable
      if [ -f "$OUTPUT_PATH.jpg" ]; then
        ffmpeg -i "$OUTPUT_PATH.jpg" -y \
        "$OUTPUT_PATH.png" >> "$LOG_PATH" 2>&1
        ffmpeg -i "$OUTPUT_PATH.mp4" -y \
          -i "$OUTPUT_PATH.png" \
          -map 1 -map 0 \
          -codec copy \
          -disposition:0 attached_pic \
          -movflags faststart \
          "$OUTPUT_PATH-artwork.mp4" >> "$LOG_PATH" 2>&1
        rm -f "$OUTPUT_PATH.mp4" "$OUTPUT_PATH.png" && mv "$OUTPUT_PATH-artwork.mp4" "$OUTPUT_PATH.mp4"
      else
        __info "$(__yellow "Artwork missing, this is a rare case, please report at my GitHub.")"
      fi
    else
      __info "$(__yellow "Output file not exists, skip embedding artwork.")"
    fi
  fi

  # Get file summary for later use
  if [[ -f "$OUTPUT_PATH.mp4" ]] || [[ -f "$OUTPUT_PATH.m4a" ]]; then

    #Add ytarchive Audio_only ext m4a
      OUTPUT_FILE="$OUTPUT_PATH.mp4"

    if [ -f "$OUTPUT_PATH.m4a" ]; then
      OUTPUT_FILE="$OUTPUT_PATH.m4a"
    fi
    DOWNLOADED_FILE_SUMMARY=`ffprobe -i \
      "$OUTPUT_FILE" \
      -v quiet \
      -print_format json \
      -show_format \
      -show_streams \
      -hide_banner`

    FILE_SUMMARY_DURATION=`echo $DOWNLOADED_FILE_SUMMARY | jq -r .streams[0].duration`
    FILE_SUMMARY_DURATION_INIT=${FILE_SUMMARY_DURATION%.*}
    FILE_SUMMARY_DURATION_CALC=$(__convert_seconds $FILE_SUMMARY_DURATION_INIT)
    FILE_SUMMARY_SIZE=`echo $DOWNLOADED_FILE_SUMMARY | jq -r .format.size`
    FILE_SUMMARY_SIZE_CALC=$(numfmt --to=iec-i --suffix=B $FILE_SUMMARY_SIZE)
    FILE_SUMMARY="Duration:  $FILE_SUMMARY_DURATION_CALC
Size:      $FILE_SUMMARY_SIZE_CALC
Path:      $HOSTNAME:$OUTPUT_FILE
" && echo -e "\n$FILE_SUMMARY"
  else
    FILE_SUMMARY="File summary not available due to missing files"
    __info "$(__yellow "File summary not available due to missing files.")"
  fi

  # Trim additional whitespace, used by email body
  FILE_SUMMARY_TRIM=`echo "$FILE_SUMMARY" | perl -pe 's/: +/: /g'`

  # Additional sleep to ensure the stream is stopped on YouTube frontend, you can also increase
  # --hls-timeout to make sure the streamer correctly stops the stream, but the longer the
  # --hls-timeout you set, the longer the notification you will get after the streamer actually
  # stops his/her stream.
  sleep 10
}

function func_callback() {
  if [ $CALLBACK == "true" ]; then
    if [ $CALLBACK_EXEC != "/dev/null" ]; then
      __info "Calling callback function..."
      local cmd=( "$CALLBACK_EXEC" "${OUTPUT_PATH}.mp4" "$BASE_DIR/" "$VIDEO_ID" "$FULLTITLE" "$UPLOADER" "$UPLOAD_DATE" )
      nohup "${cmd[@]}" &>> "$LOG_PATH" &
    else
      __info "$(__yellow "No callback executable specified.")"
    fi
  fi
}

#
# Executes
#

# Init scripts with `--init` specified
INIT_SCRIPT="${PARAM_INIT_SCRIPT:-"false"}"
if [ "$INIT_SCRIPT" == "true" ]; then
  func_check_deps
  exit 0
fi

# Print usage if no URL passed
if [ ! -n "$1" ]; then
  echo "Usage: $0 [options] url

Examples:
  Monitor specific channel, download stream when channel goes live:
  live-dl https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg/live
  live-dl https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg
  live-dl UC1opHUrw8rvnsadT-iGp7Cg
  live-dl https://youtu.be/4ZBQ1W8jV9A

  Monitor community/membership tab of specific channel (to detect member only stream), download stream when channel goes live:
  live-dl https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg/community
  live-dl https://www.youtube.com/channel/UC1opHUrw8rvnsadT-iGp7Cg/membership

  Download specific upload, this should be a live stream or finished stream
  live-dl https://www.youtube.com/watch?v=S3CAGeeMRvo
  live-dl S3CAGeeMRvo

Options:
  --mode, -m                  Running mode, default: download, available: metadata, notifier
  --output, -o                Base output directory, default: /youtube-dl/VTuber Recordings
  --membership, -mb           Use cookies_membership to download membership videos
  --remove-title, -rt         Use to remove title when download, default: false
  --archive-chat, -ac         Use to archive live chat from Youtube live stream to txt file, default: false
  --archive-chat-full, -acf   Archive live chat to json file. Support to watch on https://archive.ragtag.moe/player
  --keyword-filter, -kf       Only works in channel mode. Download if match with keyword filter, default: false (download all)
  --filter                    Filter video titles. Can be single string or regex expression. ie. ASMR|Ê≠å
  --interval, -i              Loop interval, unit: second, default: 30
  --long_interval, -li        Longer loop interval, unit: second, default: 900
  --skip-check, -c            Skip dependency check, default: false
  --skip-email                Skip sending email notification
  --skip-slack                Skip sending Slack notification
  --skip-telegram             Skip sending Telegram notification
  --skip-discord              Skip sending Discrod notification
  --callback [EXECUTABLE]     Run the callback after videos downloaded
  --address-pool [list.txt]   Use multiple addresses for curl to prevent 429 Error
  --once, -1                  Run only once, default: false
  --debug                     Show debug logs, default: false
  --no-log, -nl               No logs mode
  --audio-only, -ao           Audio only mode
  --ytarchive, -yt            Use YTARCHIVE for Youtube Live stream
  --image-proxy               Enable image proxy for China users, default: false"
  exit 1
fi

# Check if we have config.yml
if ! [ -f ./config/config.yml ]; then
  __info "$(__red "No config.yml, 'cp config.example.yml config.yml' and rerun this script.")"
  exit 1;
else
  CONFIG_RAW=`cat ./config/config.yml | yq -rR .`
  if [[ -z $CONFIG_RAW ]]; then
    __info "$(__red "Wrong config.yml format, make sure you have configured the correct format.")"
    exit 1;
  fi
fi

# Set default settings

# Remove trailing slash for user defined directory
# https://stackoverflow.com/a/1848456/412385
_PARAM_BASE_DIR=${PARAM_BASE_DIR%/*}

# Expand $HOME so that later I can replace `~` with escaped $HOME path in `config.yml`
HOME_EXPANDED=$(echo "$HOME" | sed -e 's/\//\\\//g')

CONFIG_MODE=`echo $CONFIG_RAW | jq -r '.config.mode | select(.!=null)'`
CONFIG_BASE_DIR=`echo $CONFIG_RAW | jq -r .config.output | sed -e 's/~/'"$HOME_EXPANDED"'/g'`
CONFIG_NO_LOG=`echo $CONFIG_RAW | jq -r '.config.no_log | select(.!=null)'`
CONFIG_YTARCHIVE=`echo $CONFIG_RAW | jq -r '.config.ytarchive | select(.!=null)'`
CONFIG_DIR_MEMBERSHIP=`echo $CONFIG_RAW | jq -r '.config.dir_membership | select(.!=null)'`
CONFIG_REMOVE_TITLE=`echo $CONFIG_RAW | jq -r '.config.remove_title | select(.!=null)'`
CONFIG_ARCHIVE_CHAT=`echo $CONFIG_RAW | jq -r '.config.archive_chat | select(.!=null)'`
CONFIG_ARCHIVE_CHAT_MODE=`echo $CONFIG_RAW | jq -r '.config.archive_chat_mode | select(.!=null)'`
CONFIG_KEYWORD_FILTER=`echo $CONFIG_RAW | jq -r '.config.keyword_filter | select(.!=null)'`
CONFIG_FILTER=`echo $CONFIG_RAW | jq -r '.config.filter | select(.!=null)'`
CONFIG_INTERVAL=`echo $CONFIG_RAW | jq -r '.config.interval | select(.!=null)'`
CONFIG_LONG_INTERVAL=`echo $CONFIG_RAW | jq -r '.config.long_interval | select(.!=null)'`
CONFIG_SKIP_METADATA=`echo $CONFIG_RAW | jq -r '.config.skip_metadata | select(.!=null)'`
CONFIG_SKIP_EMAIL=`echo $CONFIG_RAW | jq -r '.config.skip_email | select(.!=null)'`
CONFIG_SKIP_SLACK=`echo $CONFIG_RAW | jq -r '.config.skip_slack | select(.!=null)'`
CONFIG_SKIP_TELEGRAM=`echo $CONFIG_RAW | jq -r '.config.skip_telegram | select(.!=null)'`
CONFIG_SKIP_DISCORD=`echo $CONFIG_RAW | jq -r '.config.skip_discord | select(.!=null)'`
CONFIG_CALLBACK=`echo $CONFIG_RAW | jq -r '.config.run_callback | select(.!=null)'`
CONFIG_ADDRESS_POOL=`echo $CONFIG_RAW | jq -r '.config.address_pool | select(.!=null)'`
CONFIG_ONE_TIME=`echo $CONFIG_RAW | jq -r '.config.one_time | select(.!=null)'`
CONFIG_IMAGE_PROXY=`echo $CONFIG_RAW | jq -r '.config.image_proxy | select(.!=null)'`
CONFIG_EMAIL_PROVIDER=`echo $CONFIG_RAW | jq -r '.config.email_provider | select(.!=null)'`
CONFIG_MAILGUN_API=`echo $CONFIG_RAW | jq -r '.config.mailgun.api | select(.!=null)'`
CONFIG_MAILGUN_DOMAIN=`echo $CONFIG_RAW | jq -r '.config.mailgun.domain | select(.!=null)'`
CONFIG_MAILGUN_RECEIPT=`echo $CONFIG_RAW | jq -r '.config.mailgun.receipt | select(.!=null)'`
CONFIG_SES_ACCESS=`echo $CONFIG_RAW | jq -r '.config.ses.access | select(.!=null)'`
CONFIG_SES_SECRET=`echo $CONFIG_RAW | jq -r '.config.ses.secret | select(.!=null)'`
CONFIG_SES_DOMAIN=`echo $CONFIG_RAW | jq -r '.config.ses.domain | select(.!=null)'`
CONFIG_SES_RECEIPT=`echo $CONFIG_RAW | jq -r '.config.ses.receipt | select(.!=null)'`
CONFIG_SLACK_WEBHOOK=`echo $CONFIG_RAW | jq -r '.config.slack.webhook | select(.!=null)'`
CONFIG_TELEGRAM_BOT=`echo $CONFIG_RAW | jq -r '.config.telegram.bot | select(.!=null)'`
CONFIG_TELEGRAM_CHANNEL=`echo $CONFIG_RAW | jq -r '.config.telegram.channel | select(.!=null)'`
CONFIG_DISCORD_BOT=`echo $CONFIG_RAW | jq -r '.config.discord.bot | select(.!=null)'`
CONFIG_DISCORD_CHANNEL=`echo $CONFIG_RAW | jq -r '.config.discord.channel | select(.!=null)'`
CONFIG_CALLBACK_EXEC=`echo $CONFIG_RAW | jq -r '.config.callback.executable | select(.!=null)'`
CONFIG_ADDRESS_POOL_FILE=`echo $CONFIG_RAW | jq -r '.config.address_pool_file | select(.!=null)'`

MODE="${PARAM_MODE:-$CONFIG_MODE}"
BASE_DIR="${_PARAM_BASE_DIR:-$CONFIG_BASE_DIR}"
REMOVE_TITLE="${PARAM_REMOVE_TITLE:-$CONFIG_REMOVE_TITLE}"
ARCHIVE_CHAT="${PARAM_ARCHIVE_CHAT:-$CONFIG_ARCHIVE_CHAT}"
ARCHIVE_CHAT_MODE="${PARAM_ARCHIVE_CHAT_MODE:-$CONFIG_ARCHIVE_CHAT_MODE}"
KEYWORD_FILTER="${PARAM_KEYWORD_FILTER:-$CONFIG_KEYWORD_FILTER}"
FILTER="${PARAM_FILTER:-$CONFIG_FILTER}"
INTERVAL="${PARAM_INTERVAL:-$CONFIG_INTERVAL}"
LONG_INTERVAL="${PARAM_LONG_INTERVAL:-$CONFIG_LONG_INTERVAL}"
SKIP_METADATA="${PARAM_SKIP_METADATA:-$CONFIG_SKIP_METADATA}"
SKIP_EMAIL="${PARAM_SKIP_EMAIL:-$CONFIG_SKIP_EMAIL}"
SKIP_SLACK="${PARAM_SKIP_SLACK:-$CONFIG_SKIP_SLACK}"
SKIP_TELEGRAM="${PARAM_SKIP_TELEGRAM:-$CONFIG_SKIP_TELEGRAM}"
SKIP_DISCORD="${PARAM_SKIP_DISCORD:-$CONFIG_SKIP_DISCORD}"
CALLBACK="${PARAM_CALLBACK:-$CONFIG_CALLBACK}"
CALLBACK_EXEC="${PARAM_CALLBACK_EXEC:-$CONFIG_CALLBACK_EXEC}"
ADDRESS_POOL="${PARAM_ADDRESS_POOL:-$CONFIG_ADDRESS_POOL}"
ADDRESS_POOL_FILE="${PARAM_ADDRESS_POOL_FILE:-$CONFIG_ADDRESS_POOL_FILE}"
ONE_TIME="${PARAM_ONE_TIME:-$CONFIG_ONE_TIME}"
IMAGE_PROXY="${PARAM_IMAGE_PROXY:-$CONFIG_IMAGE_PROXY}"
NO_LOG="${PARAM_NO_LOG:-$CONFIG_NO_LOG}"
YTARCHIVE="${PARAM_YTARCHIVE:-$CONFIG_YTARCHIVE}"
URL_INPUT="$1"

if [ "IMAGE_PROXY" != "true" ]; then
  IMAGE_PROXY_BASE=""
fi

if [ "$PARAM_AUDIO_ONLY" == "true" ]; then
  MODE_AUDIO_TEXT="- AUDIO ONLY"
else
  MODE_AUDIO_TEXT=""
fi

if [ "$YTARCHIVE" == "true" ]; then
  YTARCHIVE_TEXT="- Using YTARCHIVE"
else
  YTARCHIVE_TEXT=""
fi

# Run check update first
func_check_update

# Print current variables for reference
__info "URL (URI) to process           : ${URL_INPUT}"
__info "Mode                           : ${MODE} ${YTARCHIVE_TEXT} ${MODE_AUDIO_TEXT}"
__info "Output base dir                : ${BASE_DIR}"
__info "Separate folder for membership : ${CONFIG_DIR_MEMBERSHIP}"
__info "Remove Title                   : ${REMOVE_TITLE}"
__info "Archive chat                   : ${ARCHIVE_CHAT} - Mode: ${ARCHIVE_CHAT_MODE}"
__info "Keyword filter                 : ${KEYWORD_FILTER}"
__info "Run interval (when loop)       : ${INTERVAL}"
__info "Long interval (when loop)      : ${LONG_INTERVAL}"
__info "Skip embedding metadata        : ${SKIP_METADATA}"
__info "Skip email notification        : ${SKIP_EMAIL}"
__info "Skip Slack notification        : ${SKIP_SLACK}"
__info "Skip Telegram notification     : ${SKIP_TELEGRAM}"
__info "Skip Discord notification      : ${SKIP_DISCORD}"
__info "Callback                       : ${CALLBACK}"
__info "Address Pool                   : ${ADDRESS_POOL}"
__info "Email provider                 : ${CONFIG_EMAIL_PROVIDER}"
__info "One-time execution             : ${ONE_TIME}"
__info "No log mode                    : ${NO_LOG}"

# Process URL from user parameter
func_create_url "$URL_INPUT"

# Main loop
while true; do
  __info "Checking $DL_URL..."

  # Monitor live streams of specific channel
  while true; do
    # Check if url types and live available
    # After creating URL with func_create_url, I need to further process the URL to determine
    # the type (video, live stream) and state (is live or not ) of the given URL

    if [ "$DL_PLATFORM" == "Twitch" ]; then
      func_check_state_twitch "$DL_URL"
    else
      func_check_state "$DL_URL"
    fi

    INTERVAL2=$INTERVAL
    if [ "$DL_PLATFORM" == "YouTube" ]; then
      # Get the time now and compare with upcoming time
      # If upcoming time longer than LONG_INTERVAL, live-dl will use LONG_INTERVAL
      # If upcoming time less than LONG_INTERVAL, live-dl will use INTERVAL
      if [ -n "$LONG_INTERVAL" ]; then
        __debug "Found long interval setting $LONG_INTERVAL"
        TIME_NOW=`date +%s`
        TIME_NOW=`expr $TIME_NOW + $LONG_INTERVAL`
        if [ -n "$UPCOMING_TIME" ]; then
          if [[ "$UPCOMING_TIME" > $TIME_NOW ]]; then
            INTERVAL2=$LONG_INTERVAL
          fi
        else
          INTERVAL2=$LONG_INTERVAL
        fi
      fi
    fi

    if [ "$CONTENT_STATE" == "live" ]; then
      break
    elif [ "$CONTENT_STATE" == "video" ]; then
      ONE_TIME="true"
      break
    else
      __debug "Not valid at the moment, continue running"
    fi

    __debug "Stream unavailable, retry in ${INTERVAL2}s..."
    sleep $INTERVAL2
  done

  # Get video(s) metadata
  __info  "Prepare downloading..."
  __debug "Download platform: $DL_PLATFORM"
  __debug "Download type: $DL_TYPE"
  __debug "Download mode: $MODE"

  #
  # Platform: YouTube
  #
  if [ "$DL_PLATFORM" == "YouTube" ] || [ "$DL_PLATFORM" == "Twitch" ]; then
    # Print summary
    echo -e "\n$SUMMARY"

    #
    # Type: YouTube channel
    #
    if [ "$DL_TYPE" == "channel" ] || [ "$DL_TYPE" == "Twitch" ]; then

      #
      # Mode: download
      #
      if [ "$MODE" == "download" ]; then
        # Send notifications
        # https://stackoverflow.com/a/49819711/412385
        _break=$'\n\n'
        func_send_email "üî¥ [YouTube] $UPLOADER - $FULLTITLE" "$_break$UPDATENOTE$_break$SUMMARY_TRIM$_break$DESCRIPTION" &
        func_send_slack "start" &
        func_send_telegram "start" &
        func_send_discord "start"
        func_archive_chat &
        if [ "$DL_TYPE" == "Twitch" ]; then
          func_download_twitch
        else
          func_download_youtube
        fi
        func_finalize_download
        func_send_discord "stop" &
        func_send_email "‚ö´Ô∏è [YouTube] $UPLOADER - $FULLTITLE" "$FILE_SUMMARY_TRIM" &
        func_callback

      #
      # Mode: metadata only
      #
      elif [ "$MODE" == "metadata" ]; then
        __info "Metadata only mode, no video will be downloaded."
        exit 0

      #
      # Mode: notifier
      #
      elif [ "$MODE" == "notifier" ]; then
        func_send_slack "start" &
        func_send_telegram  "start" &
        func_send_discord "start"
        __info "Notifier mode, no video will be downloaded, continue monitoring..."

        while true; do
          if [ "$DL_PLATFORM" == "Twitch" ]; then
            func_check_state_twitch "$DL_URL" "lazy"
          else
            func_check_state "$DL_URL" "lazy"
          fi

          if [ "$CONTENT_STATE" != "live" ]; then
            __info "Live stopped"
            func_send_slack "stop" &
            func_send_telegram "stop" &
            func_send_discord "stop"
            break
          fi

          __info "Still streaming, retry in ${INTERVAL2}s..."
          sleep $INTERVAL2
        done

      #
      # Mode: unknown
      #
      else
        __info "$(__red "Unknown mode, check your config")"
        exit 1
      fi

    #
    # Type: YouTube video
    #
    elif [ "$DL_TYPE" == "video" ]; then

      if [ "$MODE" == "download" ]; then
        func_archive_chat &
        func_download_youtube
        func_finalize_download
        func_callback
        exit 0
      else
        __info "Metadata only mode, no video will be downloaded."
        exit 0
      fi

    #
    # Type: YouTube playlist
    #
    elif [ "$DL_TYPE" == "playlist" ]; then
      __info "Type: YouTube playlist"

    #
    # Type: Unknown
    #
    else
      __info "Type: Unknown"
    fi

  elif [ "$DL_PLATFORM" == "bilibili" ]; then
    __info "Download platform: Bilibili"
  else
    __info "Download platform: Unknown"
  fi

  # Break current loop if only run once
  [ "$ONE_TIME" == "true" ] && break
done
